# Generated by Django 4.2.16 on 2025-11-23 14:01

from django.db import migrations, models
from django.db.models import F

def copy_end_from_date(apps, schema_editor):
    Job = apps.get_model("jobs", "Job")
    # Use the historical field name 'date' (exists in migration state) to populate end_date
    Job.objects.filter(end_date__isnull=True).update(end_date=F("date"))

class Migration(migrations.Migration):

    dependencies = [
        ("jobs", "0010_add_ongoing_status_to_application"),
    ]

    operations = [
        # 1) Add end_date as nullable so we can populate it from the existing 'date' column.
        migrations.AddField(
            model_name="job",
            name="end_date",
            field=models.DateField(null=True, blank=True, db_index=True),
        ),

        # 2) Data migration: copy existing date -> end_date using the historical model (which still has 'date').
        migrations.RunPython(copy_end_from_date, reverse_code=migrations.RunPython.noop),

        # 3) Rename the DB column `date` -> `start_date` and also update the migration state
        #    so Django knows the field has been renamed (state_operations avoids Django trying
        #    to rebuild the table using a historical model that lacks 'date').
        migrations.RunSQL(
            sql="ALTER TABLE jobs_job RENAME COLUMN date TO start_date;",
            reverse_sql="ALTER TABLE jobs_job RENAME COLUMN start_date TO date;",
            state_operations=[
                migrations.RenameField(
                    model_name="job",
                    old_name="date",
                    new_name="start_date",
                )
            ],
        ),

        # (Optional) If you want end_date to be non-nullable in models.py, perform an AlterField
        # here after data copy; leaving nullable is safest to avoid errors during migration.
    ]
